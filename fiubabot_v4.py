# -*- coding: utf-8 -*-
"""FIUBABOT V4.ipynb

"""Automatically generated by Colab.
"""

# ===============================================**DESCARGA DE LIBRERÍAS**=============================================
    
#__________Librerias Telegram_________________________________________________________________________________
#https://core.telegram.org/bots/samples

!pip install AIOGram
!pip install python-telegram-bot
!pip install pyTelegramBotAPI
!pip install telegram.py
!pip install Telegrinder
!pip install Wonda
!pip install MicroPython
!pip install pure-teleapi
!pip install telegram-text
!pip install OrigamiBot

!pip install -U python-telegram-bot nest_asyncio
import nest_asyncio
nest_asyncio.apply()

#__________Librerias de lógica, NLP y predicción_________________________________________________________________________________

!pip install gspread oauth2client transformers torch

!pip install fuzzywuzzy[speedup]
!pip install --upgrade gspread gspread-dataframe

from sentence_transformers import SentenceTransformer, util


# =====================================================**LÓGICA CHATBOT**=====================================================
# En esta instancia ya tenemos todas las liberías necesarias. A continuación avanzamos con el inicio de la lógica del chatbot

import gspread
from gspread_dataframe import get_as_dataframe

_____________________________# Autenticar y conectar con Google Sheets. Deberá iniciarse sesión en google Drive.____________________
from google.colab import auth
auth.authenticate_user()

# Autorizar con permisos de Google Drive
from google.auth import default
creds, _ = default()
client = gspread.authorize(creds)

import pandas as pd
from transformers import pipeline
from flask import Flask, request, jsonify
from fuzzywuzzy import process


#Ahora que tenemos el acceso al google sheets, avanzamos con la lectura de datos
#MEJORA FUTURA: AGREGAR EL LECTURAS ENTRE LAS FUNCIONES QUE SE DEFINEN POSTERIORMENTE PARA QUE LA INFORMACIÓN SE ACTUALICE AL INSTANTE.


# Abre la hoja de cálculo por su URL o ID
sheet_url = "https://docs.google.com/spreadsheets/d/16XAX3kozPOU5LcPk6gvkO4LJcUTNfj0g3oAXL7cbzSE/edit?usp=drive_link"
spreadsheet = client.open_by_url(sheet_url)

# Selecciona la primera hoja de trabajo
sheet = spreadsheet.sheet1

# Carga los datos en un DataFrame
data = get_as_dataframe(sheet)

# Convertir valores NaN en la columna 'Materia' a cadenas vacías
data["ASIGNATURA"] = data["ASIGNATURA"].fillna("").astype(str).str.strip()
data["CODIGO"] = data["CODIGO"].fillna("").astype(str).str.strip()

#Bajar tabla de aulas, y de horarios, y de códigos de materia <- estos están actualmente alojados en la 'hoja 1'
asignaturas_dict_aula = dict(zip(data["ASIGNATURA"], data["AULA"]))
asignaturas_dict_hora = dict(zip(data["ASIGNATURA"], data["HORA"]))
asignaturas_dict_codigo = dict(zip(data["ASIGNATURA"], data["CODIGO"]))
codigo_dict_aula = dict(zip(data["CODIGO"], data["AULA"]))
codigo_dict_hora = dict(zip(data["CODIGO"], data["HORA"]))
codigo_dict_asignatura = dict(zip(data["CODIGO"], data["ASIGNATURA"]))


#Repetimos para la hoja 2 -> actualmente en la hoja 2 guardamos información sobre los procesos de la facultad.
sheet2 = spreadsheet.worksheet("Hoja 2")
data2 = get_as_dataframe(sheet2)
data2["PROCESO"] = data2["PROCESO"].fillna("").astype(str)
proceso_dict_detalle = dict(zip(data2["PROCESO"], data2["DETALLE"]))
proceso_dict_links = dict(zip(data2["PROCESO"], data2["ENLACES"]))

# Inicializar el modelo NLP
qa_pipeline = pipeline("question-answering")
# Inicializar la app Flask
app = Flask(__name__)




__________________________# Clasificador de preguntas con embeddings semánticos____________

# Plantillas de ejemplo para cada categoría
# MEJORA FUTURA: estas planillas 'manuales' pueden reemplazarse por otras refinadas y más completas descargadas desde paquetes de internet.

plantillas = {
    "AULA": [
        "¿Dónde está?",
        "¿Dónde curso?",
        "¿Dónde puedo encontrar?",
        "¿Dónde queda?",
        "¿Dónde se encuentra?"
    ],
    "HORA": [
        "¿Cuándo es?",
        "¿Cuándo ocurre?",
        "¿Cuándo sucede?",
        "¿Cuándo puedo ir?",
        "¿Cuándo se cursa?"
    ],
    "PROCESO": [
        "¿Cómo puedo hacer?",
        "¿Cómo funciona?",
        "¿Cómo hago?",
        "¿Cómo es?",
        "¿Cómo se hace?",
        "¿Cómo es el proceso?"
    ],
    "SALUDO": [
        "Hola",
        "Buenos días",
        "Buenas tardes",
        "Buenas noches",
        "Saludos",
        "qué tal",
        "Hola cómo estás?"
    ],
    "DESPEDIDA": [
        "Adiós",
        "Chau",
        "Hasta luego",
        "Gracias",
        "Gracias por hablar conmigo",
        "Hasta pronto"
    ]
}


# Descargamos un modelo NLP (español)
modelo = SentenceTransformer('distiluse-base-multilingual-cased-v2')

# Se generan los 'embeddings' (vectores de información de legunaje) para las planillas cargadas
embeddings = {}
for categoria, ejemplos in plantillas.items():
    embeddings[categoria] = modelo.encode(ejemplos, convert_to_tensor=True)

# Definimos la función para clasificar una pregunta en las categorías que creamos.
def clasificar_pregunta(pregunta):
    embedding_pregunta = modelo.encode(pregunta, convert_to_tensor=True)
    mejor_categoria = None
    mejor_sim = -1

    for categoria, emb_cat in embeddings.items():
        # Calculamos similitud con cada ejemplo de la categoría
        similitudes = util.cos_sim(embedding_pregunta, emb_cat)
        sim_max = similitudes.max().item()  # tomamos la coincidencia más alta

        if sim_max > mejor_sim:
            mejor_sim = sim_max
            mejor_categoria = categoria

    return mejor_categoria, round(mejor_sim, 3)

# --- Ejemplo de uso ---
preguntas = [
    "¿Dónde está la estación?",
    "¿Cuándo es la reunión?",
    "¿Cómo llego al centro?",
    "Hola como estás?",
    "Gracias!",
    "chau"
]

for pregunta in preguntas:
    categoria, score = clasificar_pregunta(pregunta)
    print(f"Pregunta: {pregunta}")
    print(f"Categoría: {categoria} (Similitud: {score})\n")

# ____________________Función para buscar el AULA de una asignatura con NLP y coincidencia flexible__________________________________
def buscar_aula(pregunta):
    # Analizar la pregunta para encontrar posibles asignaturas con su nombre de asignatura (búsqueda exacta)
    respuesta = qa_pipeline(question=pregunta, context=" ".join(asignaturas_dict_aula.keys()))
    materia_mencionada = respuesta['answer']
    aula = asignaturas_dict_aula.get(materia_mencionada)

    # Si no encuentra por el nombre de la asignatura, buscamos por el código
    if aula is None:
        respuesta = qa_pipeline(question=pregunta, context=" ".join(codigo_dict_aula.keys()))
        respuesta = qa_pipeline(question=pregunta, context=" ".join(codigo_dict_asignatura.keys()))
        codigo_detectado = respuesta['answer'].strip()
        if codigo_detectado in codigo_dict_asignatura:
            materia_mencionada = codigo_dict_asignatura[codigo_detectado]
            aula = asignaturas_dict_aula.get(materia_mencionada)



    # Si aún no encuentra la asignatura con el modelo NLP, utiliza coincidencias flexibles respecto a la asignatura
    if aula is None:
        # Encontrar la mejor coincidencia con fuzzywuzzy (umbral de coincidencia: 70%)
        asignatura_similar, score = process.extractOne(pregunta, asignaturas_dict_aula.keys())
        if score >= 70:  # Si la similitud es suficientemente alta
            aula = asignaturas_dict_aula[asignatura_similar]


        # Si aún no encuentra el elemento con el modelo NLP, utiliza coincidencias flexibles respecto al código
        codigo_similar, score = process.extractOne(pregunta, codigo_dict_asignatura.keys())
        if score >= 70:  # Si la similitud es suficientemente alta
            materia_mencionada = codigo_dict_asignatura[codigo_similar]
            aula = codigo_dict_aula[codigo_similar]


    if materia_mencionada is not None:
      materia_hallada = materia_mencionada


    if asignatura_similar is not None:
       materia_hallada = asignatura_similar


    # Devolver el resultado, o un mensaje predefinido si no se encuentra
    if aula:
        return f"{materia_hallada} se cursa en el aula {aula}"
    else:
        return "No tengo información sobre el aula de esa asignatura."

# _____________________Función para buscar el HORARIO de una asignatura con NLP y coincidencia flexible____________________________
def buscar_hora(pregunta):
    # Analizar la pregunta para encontrar posibles asignaturas
    respuesta = qa_pipeline(question=pregunta, context=" ".join(asignaturas_dict_hora.keys()))
    materia_mencionada = respuesta['answer']
    hora = asignaturas_dict_hora.get(materia_mencionada)

 # Si no encuentra por el nombre de la asignatura, buscamos por el código
    if hora is None:
        respuesta = qa_pipeline(question=pregunta, context=" ".join(codigo_dict_hora.keys()))
        respuesta = qa_pipeline(question=pregunta, context=" ".join(codigo_dict_asignatura.keys()))
        codigo_detectado = respuesta['answer'].strip()
        if codigo_detectado in codigo_dict_asignatura:
            materia_mencionada = codigo_dict_asignatura[codigo_detectado]
            hora = asignaturas_dict_hora.get(materia_mencionada)




    # Si aún no encuentra la asignatura con el modelo NLP, utiliza coincidencias flexibles
    if hora is None:
        # Encontrar la mejor coincidencia con fuzzywuzzy (umbral de coincidencia: 70%)
        asignatura_similar, score = process.extractOne(pregunta, asignaturas_dict_hora.keys())
        if score >= 70:  # Si la similitud es suficientemente alta
            hora = asignaturas_dict_hora[asignatura_similar]



        # Si aún no encuentra el elemento con el modelo NLP, utiliza coincidencias flexibles respecto al código
        codigo_similar, score = process.extractOne(pregunta, codigo_dict_asignatura.keys())
        if score >= 70:  # Si la similitud es suficientemente alta
            materia_mencionada = codigo_dict_asignatura[codigo_similar]
            hora = codigo_dict_hora[codigo_similar]



    if materia_mencionada is not None:
      materia_hallada = materia_mencionada


    if asignatura_similar is not None:
       materia_hallada = asignatura_similar



    # Devolver el resultado, o un mensaje predefinido si no se encuentra
    if hora:
        return f"El horario de cursada de {materia_hallada} es de {hora}"
    else:
        return "No tengo información sobre el horario de esa asignatura."

# ________________________________________Función para buscar un PROCESO de la facultad_________________________________________
def buscar_proceso(pregunta):
    # Analizar la pregunta para encontrar posibles procesos
    respuesta = qa_pipeline(question=pregunta, context=" ".join(proceso_dict_detalle.keys()))
    proceso_mencionado = respuesta['answer']

    # Intentar una búsqueda exacta
    detalle = proceso_dict_detalle.get(proceso_mencionado)

    # Si no encuentra la asignatura con el modelo NLP, utiliza coincidencias flexibles
    if detalle is None:
        # Encontrar la mejor coincidencia con fuzzywuzzy (umbral de coincidencia: 70%)
        proceso_similar, score = process.extractOne(pregunta, proceso_dict_detalle.keys())
        if score >= 70:  # Si la similitud es suficientemente alta
            detalle = proceso_dict_detalle[proceso_similar]

    # Devolver el resultado, o un mensaje predefinido si no se encuentra
    if detalle:
        return detalle
    else:
        return "No tengo información sobre el proceso consultado."

def respuesta_chatbot(user_text):
    mejor_categoria, puntaje = clasificar_pregunta(user_text)

    #print(f"Categoría: {mejor_categoria} (Puntaje: {puntaje})")

    if mejor_categoria == "AULA":
        respuesta = buscar_aula(user_text)
    elif mejor_categoria == "HORA":
        respuesta = buscar_hora(user_text)
    elif mejor_categoria == "PROCESO":
        respuesta = buscar_proceso(user_text)
    elif mejor_categoria == "SALUDO":
        respuesta = "Hola! ¿En qué puedo ayudarte? Podes consultarme por horarios o aulas en las que cursar cierta materia. También podes consultarme sobre otros procesos sobre los que tengas dudas."
    elif mejor_categoria == "DESPEDIDA":
        respuesta = "Hasta luego!"
    else:
        respuesta = "No entendí tu pregunta; ¿podrás redactarla de otra manera? ¡Gracias!."

    print(f"Pregunta: {user_text}\nRespuesta: {respuesta}")



#===========================CONEXIÓN CON BOT TELEGRAM===========================================

import nest_asyncio
nest_asyncio.apply()

from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters

# Bot token
BOT_TOKEN = ' INSERTAR TOKEN '

# === 1. Comando /start ===
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Iniciando FIUBABOT - Versión piloto"
    )

# === 2. Lógica de respuesta ===
def respuesta_chatbot(user_text):
    mejor_categoria, puntaje = clasificar_pregunta(user_text)

    if mejor_categoria == "AULA":
        respuesta = buscar_aula(user_text)
    elif mejor_categoria == "HORA":
        respuesta = buscar_hora(user_text)
    elif mejor_categoria == "PROCESO":
        respuesta = buscar_proceso(user_text)
    elif mejor_categoria == "SALUDO":
        respuesta = (
            "Hola! ¿En qué puedo ayudarte? Podés consultarme por horarios o aulas "
            "en las que cursar cierta materia. También podés preguntarme sobre otros procesos."
        )
    elif mejor_categoria == "DESPEDIDA":
        respuesta = "¡Hasta luego!"
    else:
        respuesta = "No se pudo clasificar la pregunta."

    print(f"Pregunta: {user_text}\nRespuesta: {respuesta}")
    return respuesta

# === 3. Manejador general de mensajes ===
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_text = update.message.text
    respuesta = respuesta_chatbot(user_text)
    await update.message.reply_text(respuesta)

# === 4. Crear aplicación y agregar handlers ===
app = ApplicationBuilder().token(BOT_TOKEN).build()

app.add_handler(CommandHandler("start", start))
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

# === 5. Ejecutar el bot ===
print("Bot is running...")
await app.run_polling()
